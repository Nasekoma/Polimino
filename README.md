# Polimino
В приложенном файле (polimino.py) находится код, выполняющий проверку возможности замощения заданного прямоугольника заданными наборами полимино. В файле Polimino_task.pdf находится постановка задачи.
При запуске программы необходимо сначала ввести через пробел размеры прямоугольника (после соответствующего сообщения в консоли), далее ввести через пробел последовательно все числа, относящиеся к прямоугольным полимино в следующем порядке: длина меньшей стороны, длина большей стороны, количество прямоугольников данного вида; затем в том же порядке данные, относящиеся к следующему виду прямоугольников (данные вводятся после соответствующего сообщения в консоли). Затем необходимо ввести таким же образом данные о п-образных полимино, однако сначала вводится длина левой и правой "каёмок", а потом длина верхней.
В процессе обработки введённых данных они приводятся сначала к виду, заданному в задаче, а затем к виду, более удобному для дальнейшей работы.
В случае, если вы хотите использовать уже существующие переменные (например, из другого файла) пропустите часть кода, относящуюся к указанному выше процессу (она отмечена комментариями) и дополните код необходимым образом. Переменная, отвечающая за размеры исходного прямоугольника (стола) ‒ table_size; переменная, содержащая данные о прямоугольных полимино ‒ rectangle_tuples; переменная, содержащая данные о п-образных полимино ‒ type2_tuples.
Перед запуском основного алгоритма выполняется проверка площади: меньше ли суммарная площадь заданных полимино, чем площадь прямоугольника. Если это не так, то выдается ответ "False", и программа завершается. Таким же образом выполняется проверка сторон полимино: меньше ли они сторон прямоугольника.
Далее создается массив из объектов класса Figure, который представляет собой просто набор данных, к которым удобно обращаться по названиям полей. К полям класса Figure относятся:
•	size = (size1, size2) ‒ размеры данного вида полимино в порядке аналогичном порядку при вводе
•	num ‒ количество полимино данного вида
•	type ‒ число, равное либо 0, если это прямоугольник, либо 1, если это п-образный полимино
•	largest_side ‒ длина большей стороны полимино данного вида
•	matrix ‒ прямоугольная матрица (двумерный список) из 0 и 1, отображающая полимино данного вида (1 ‒ клетка относится к полимино, 0 ‒ не относится)
Массив называется all_tuples. Массив сортируется в порядке невозрастания по полю largest_side, то есть по длине большей стороны. Это сделано для небольшой оптимизации работы алгоритма в среднем. 
Далее начинается основной алгоритм. На каждом этапе рассматривается объект полимино, который алгоритм пытается разместить на доске. Если разместить получается, то происходит переход к следующему объекту полимино. Если разместить не получается, то алгоритм меняет положение полимино и снова пытается его разместить. Если ни в одном из положений полимино разместить не удаётся, алгоритм возвращается к предыдущему полимино с промежуточным результатом False (рекурсия). Если алгоритм возвращается к некоторому полимино, то он снова пытается его разместить на доске, но уже в новом месте. Поиск размещения идет построчно, то есть задаются координаты верхнего левого угла полимино, проверяется возможность разместить его по этим координатам, если же не получается, то координаты сдвигаются вправо на одну клетку. Если алгоритм доходит до конца строки, то он переходит на одну строку ниже в первую клетку. В процессе для небольшой оптимизации выполняются предварительные проверки координат перед попыткой размещения полимино.
В общем случае алгоритм работает за O(n!).
 

Список функций:
•	create_matrix(size, type) ‒ функция создает матрицу для поля matrix класса Figure. Возвращает полученную матрицу. Аргументы: 
o	size = (int, int)
o	type = int.
•	rotate_matrix(matrix) ‒ функция “поворачивает” матрицу, меняя местами оси x и y. Возвращает полученную матрицу. Аргумент matrix = [[int, …], …] (двумерный список из 0 и 1).
•	flip_matrix(matrix) ‒ функция “отражает” матрицу по вертикали и по горизонтали (одновременно). Возвращает полученную матрицу. Аргумент matrix = [[int, …], …] (двумерный список из 0 и 1).
•	matrix_number(matrix) ‒ функция интерпретирует матрицу из нулей и единиц как число в двоичной системе счисления и переводит в десятичную. Возвращает полученное число. Аргумент matrix = [[int, …], …] (двумерный список из 0 и 1).
•	place_figure(table, figure, coords) ‒  функция “размещает” фигуру на доске так, чтобы координаты верхнего левого угла фигуры оказывались на координатах coords на доске, проверяется пересечение с уже заполненными клетками на доске. Возвращает результат размещения (True, если разместить получилось, False, если нет) и полученную доску. Аргументы:
o	table = [[int, …], …] (двумерный список из 0 и 1)
o	figure = [[int, …], …] (двумерный список из 0 и 1)
o	coords = [int, int]
•	search_for_place(table, figure, coords) ‒ функция ищет место для фигуры на доске и размещает её, если место найдено. Возвращает результат размещения (True, если место найдено, False, если нет) и полученную доску. Аргументы:
o	table = [[int, …], …] (двумерный список из 0 и 1)
o	figure = [[int, …], …] (двумерный список из 0 и 1)
o	coords = [int, int, bool] 
•	filling(start_table, all_tuples, index, num) ‒ функция, выполняющая основной алгоритм. Возвращает результат его выполнения (True, если доску замостить можно, False, если нет). Аргументы:
o	start_table = [[int, …], …] (двумерный список из 0 и 1)
o	all_tuples = [Figure, …] (список из объектов класса Figure)
o	index = int (индекс рассматриваемого вида полимино)
o	num = int (число оставшихся для размещения объектов полимино рассматриваемого вида)
•	is_fillable(table_size, all_tuples) ‒ функция готовит матрицу из нулей, соответствующую пустому столу, и обращается к предыдущей функции, запуская алгоритм. Возвращает результат выполнения основного алгоритма (True, если доску замостить можно, False, если нет). Аргументы:
o	table_size = (int, int)
o	all_tuples = [Figure, …] (список из объектов класса Figure
